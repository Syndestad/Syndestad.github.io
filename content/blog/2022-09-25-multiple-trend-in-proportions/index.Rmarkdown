---
title: For-loop for Multiple Trend in Proportions
author: R package build
date: '2022-09-25'
slug: []
categories:
  - R
  - Statistics
  - Clinical science
tags:
  - prop.trend.test
  - tidyverse
  - Chi-square
  - Categoricals
  - for-loop
  - write.xlsx()
subtitle: ''
draft: yes
series: ~
layout: single
excerpt: 'When you have only one parameter to test, following my previous tutorial for test for trends in proportions will be sufficient. However, if you have many independent variables to be tested across several dependent variables, it may become quite tedious to do them all one by one. Therefore, I wrote a for-loop that will create all the summary-tables, perform the test for trends in proportions for each table, add the test result to the count matrix and save the output neatly in a csv/excel format. Here I explain each step in the process.'
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

When you have only one parameter to test, following the [tutorial](https://syndestad.netlify.app/blog/2021-08-09-test-for-trend-in-proportions/) for test for trends in proportions or using the online calculator [here](https://epitools.ausvet.com.au/trend) will be sufficient.
However, if you have many independent variables to be tested across several dependent variables, it may become quite tedious to do them all one by one. 
Therefore, I wrote a for-loop that will create all the summary-tables, perform the test for trends in proportions for each table, add the test result to the count matrix and save the output neatly in a csv/excel format. Here I explain each step in the process.

## Import your data. 

Load the necessary packages.
```{r, message = FALSE}
library(tidyverse)
library(clinfun)
```


```{r}
# Generate random input data:
df = tibble(Subject = LETTERS[1:20],
            Response = sample(x = c("CR", "PR", "SD", "PD"), size  = 20, replace = TRUE),
            Biomarker1 =  sample(x = c("High", "Low"), size  = 20, replace = TRUE),
            Biomarker2 =  sample(x = c("High", "Low"), size  = 20, replace = TRUE),
            Biomarker3 =  sample(x = c("Wt", "Mutated"), size  = 20, replace = TRUE))

# Set factor levels
df$Response = factor(df$Response,levels = c("CR", "PR", "SD", "PD"))
df$Biomarker1 = factor(df$Biomarker1, levels = c("High", "Low")) 
df$Biomarker2 = factor(df$Biomarker2, levels = c("High", "Low")) 
df$Biomarker3 = factor(df$Biomarker3, levels = c("Wt", "Mutated")) 

head(df)
```

Your dependent variable, in this case "Response", need to be in correct order for the prop.trend.test(). We want CR=1, PR=2, SD=3 and PD=4.
Verify that the levels are in correct order with `levels()`, and adjust with `factor()` if it needs to be corrected.
```{r}
levels(df$Response)
```



## Create an output directory and **name your output-file**:

First, name your `OutputFileName` appropriately. 
An appropriate name may include **which data** is used, the  **method** used to generate it and the **date** it was created.  Avoid white space and special characters in names.

The next line will create an output folder in your working directory `here::here()`. If the folder already exist, it will print that the folder already exist.  
Then it will set the path relative to `here::here()` with the full name of the final output file with a csv-extension using the OutputFileName variable. 
```{r}
# Specify name of output file
OutputFileName = "MyResults_TestForTrendInProportions"

# Create output folder if it does not already exist.
if (!dir.exists("output")){dir.create("output")} else {print(paste0("output", " already exists!"))}

# Set output filepath relative to here::here()
outputFile = here::here(paste0("output/",OutputFileName, ".csv"))
```

Choose the variables from your data.frame to include in the `prop.trend.test()`.  
The function will loop over all independent variables and fetch the names from the **IndependentVariableName** vector for the final output. Therefore, it is important to add the names in **the same order** as the variables are named from. 
Adding a separate vector for the names allows us to specify the names to be different from how they appear in the column names.
```{r}
IndependentVariableName =  c("Biomarker Nr1", "Biomarker Nr2", "Biomarker Nr3")  # Cause, variable name to be put in the table
DependentVariableName =    c("Response")                                         # Effect, variable name to be put in the table

# Create dataframe with selected variables
IndependentVariable = df %>% select("Biomarker1", "Biomarker2", "Biomarker3") # Cause variable(s) 
DependentVariable = df$Response                                               # Effect variable

# Have a look at the variables to be tested:
head(IndependentVariable)
```

## The for-loop

Now, run the for-loop that calculates test for trends in proportion for each variable iteratively, and saves the output including all summary variables.

```{r, echo = FALSE}
# Hidden filepath for webpage purposes
outputFile = "/Users/syndestad/Documents/Syndestad.github.io/content/blog/2022-09-25-multiple-trend-in-proportions/output/MyResults_TestForTrendInProportions.csv"
```


```{r}
# For every IndependentVariable, do:
for (i in seq_along(IndependentVariable)) {
# Print the name for visual control
print(IndependentVariableName[[i]])
# Create a table of count data of the independent and dependent variable:  
tbl = table(IndependentVariable[[i]], DependentVariable)
 
print(tbl)

# Get the number of counts in the table
n = colSums(tbl)

# Do the Proportional Trend Test for the first row in the table
ptt1 = prop.trend.test(tbl[1,], n, score = seq_along(tbl[1,])) 
# The result for row 1 and 2 should be equal
#ptt2 = prop.trend.test(tbl[2,], n, score = seq_along(tbl[2,])) 
print(ptt1)

# Use broom to save a tidy output of the test:
t.tt = broom::tidy(ptt1)
# Edit name of statistic output
colnames(t.tt)[colnames(t.tt) == "statistic"] = "X-squared"
# Add the name of the variables used for the test result
t.tt$DependentVariable = DependentVariableName
t.tt$IndependentVariable = IndependentVariableName[[i]]

# Reorder columns and remove parameter column
t.tt = t.tt %>% select(DependentVariable, IndependentVariable, everything(), -parameter)
# Add empty row since the count data has two rows and the test has one.
t.tt[nrow(t.tt)+1,] <- NA
print(t.tt)

# Add the Summary Table to test result
## Turn the table into a data-frame
tbl.m = tbl %>% as.data.frame.matrix() 
## Add the rownames
tbl.m$Condition = rownames(tbl)
## Add the table to the test-results by cbind
output = tbl.m %>% cbind(t.tt)
# Reorder output for estetics
output = output %>% select(DependentVariable,	IndependentVariable, Condition, everything())
print(output)

# Write results to outputFile. Append results to outputFile one sample pr loop
  write.table(output, file = outputFile, sep = ",", 
              row.names = FALSE, col.names=!file.exists(outputFile),
              quote = FALSE, append = TRUE)

}
```

Now we can look at the result by importing the outputFile with `read_csv()`
```{r, message= FALSE}
TheOutput = read_csv(outputFile)
```


```{r}
library(DT)
datatable(TheOutput, 
              rownames = FALSE, 
              colnames = colnames(TheOutput),
              options = list(searching=FALSE)) %>%
              formatRound(columns=c('X-squared', 'p.value'), digits=3)
```


Optionally, save the final results as an excel file.
```{r}
openxlsx::write.xlsx(TheOutput, paste0("output/", OutputFileName, ".xlsx"))
```

Boom! You have completed your task in no time! Now go find out what the results mean.

```{r}
sessionInfo()
```





