---
title: Dragen QC report template for multiple samples from fastqc metrics
author: Synn√∏ve Yndestad
date: '2022-02-14'
slug: []
categories:
  - R
  - sequencing
  - RNAseq
tags:
  - Illumina
  - Dragen
  - NGS
  - tidyverse
  - Rmarkdown
  - Plotly
  - MultiQC
  - fastQC
subtitle: ''
excerpt: 'A Rmarkdown report generator for Dragen fastqc metrics'
---


For RNAseq performed on the Illumina NovaSeq6000, a single RNAseq run may contain 70 different samples. Batch aggregating and plotting Quality Control metrics from a sequencing run is very useful to spot samples with low sequencing quality within a single run.  
While [multiQC](https://multiqc.info)  is an excellent tool for aggregating and visualizing QC metrics, my RNAseq project is run using the Dragen pipeline. Since no Dragen module had yet been implemented when I was processing the samples, I wrote my own version in the form of a Rmarkdown report template. It takes a folder of *.fastq_metrics.csv files generated by Dragen, and produces a html report with plots made interactive by plotly.  


An example report can be viewed [here](https://syndestad.netlify.app/shadow/Dragen-multi-QC-report-template-for-fastqc_metrics.html).  
The Rmarkdown template and the example report can be found in my GitHub [here](https://github.com/Syndestad/R-box/tree/main/Dragen/1_Dragen_Multiple_QC_report_template).


**Instructions for use:**  
1- Add a folder containing the *fastq_metrics.csv files to the working directory.   
   The folder name will be assigned as RunID.  
2- Change any run-specific details in the  **Description** section to document for future reference i.e  what kind of samples, from which study, what prep protocol generated the library and which dragen version was used in the processing.  
3- Knit report  
  
  
The plots produced will be the same kind of plots listed below.

```{r, echo =FALSE, message=FALSE, results='hide'}
library(tidyverse)
#Get directory , change Foldername as appropiate to str-remove folder name in filenames
dir <- gsub("\\./", "", list.dirs(recursive=FALSE)[-1]) %>% paste("/", sep= "")
#directory <- "dragen_fastqc/"
RunID <- gsub("\\./", "", list.dirs(recursive=FALSE)[-1])
```

#### Plots produced by the report:


```{r, echo =FALSE, message=FALSE, results='hide'}
# read folder
library(tidyverse)
library(ggplot2)
library(plotly)


#Find all gene quantification files in the current folder and all subfolders and list file-names as tempFiles
tempFiles <- list.files(pattern="*fastqc_metrics.csv",recursive = TRUE)

#Import files as lists of dataframes
myList = sapply(tempFiles, read.csv, header = FALSE, simplify = FALSE, USE.NAMES = TRUE)
 
#inspect the first 10 rows in the first data frame in the list to see what kind of data you have
head(pluck(myList, 1), n = 10)  
```


```{r,  echo =FALSE, message=FALSE, results='hide'}
# Merge lists of dataframes, create an id column with sample name and select relevant columns and remove the list of data frames to save space.
All_files <- map_df(myList, ~as.data.frame(.x), .id="Sample")

# Optional, clean up sample names. Change if necessary.
All_files$Sample <- str_remove(All_files$Sample, dir)
All_files$Sample <- str_remove(All_files$Sample, ".fastqc_metrics.csv")
  
head(All_files, n= 4)

# Add Read1 Read" to sample name.
All_files$Sample <- paste(All_files$Sample, All_files$V2, sep = "_")
head(All_files, n= 4)
rm(myList)
```








#### 1- Read Mean quality; Per-Sequence Quality Scores 
  
Total number of reads. Each average Phred-scale quality value is rounded to the nearest integer.

```{r, echo =FALSE, message=FALSE, results='hide'}
read_mean_quality  <- All_files %>% filter(V1 == "READ MEAN QUALITY")

read_mean_quality$V3 <- read_mean_quality$V3 %>% str_remove("Q") %>% 
                                                 str_remove(" Reads") %>% 
                                                 as.numeric()
```


```{r, echo =FALSE, message=FALSE}
p <-ggplot(data =read_mean_quality,  aes(x= V3, y=V4, group = Sample, color = Sample )) +
    labs(title ="Dragen-QC: Per-Sequence Quality Scores", y= "Count", x = "Mean Phred Quality Score") +
    geom_line() +
    theme(legend.position = "none")  +
   # theme(axis.text.x = element_text(angle=45)) +
    scale_y_continuous(labels = scales::label_comma() ) +
    scale_x_continuous(breaks = scales::pretty_breaks(n = 15)) +
    theme_minimal()

ggplotly(p)%>% layout(showlegend = FALSE)
```



#### 2- Positional Base Mean Quality; Per-Base Quality Scores

Average Phred-scale quality value of bases with a specific nucleotide at a given location in the read. Locations are listed first and can be either specific positions or ranges. The nucleotide is listed second and can be A, C, G, or T. N or ambiguous bases are assumed to have the system default value, usually QV2.

```{r, echo =FALSE, message=FALSE, results='hide'}
position_base_mean_quality  <- All_files %>% filter(V1 == "POSITIONAL BASE MEAN QUALITY")
head(position_base_mean_quality)
```



```{r, echo =FALSE, message=FALSE, results='hide'}
position_base_mean_quality <- position_base_mean_quality %>% separate(V3, c("Pos", "ReadPos", "Base", "AvgQ", "AvgQ2"))
position_base_mean_quality$ReadPos <- as.numeric(position_base_mean_quality$ReadPos)
head(position_base_mean_quality)
```

 
```{r, echo =FALSE, message=FALSE}
p <-ggplot(data =position_base_mean_quality,  aes(x= ReadPos, y=V4, color = Sample )) +
    labs(title ="Dragen-QC: Per-Base Quality Scores", y= "Avg Phred Quality Score", x = "Base position") +
    geom_line() +
    theme(legend.position = "none") +
    theme(axis.text.x = element_text(size=5, angle=45))+
    facet_wrap("Base") +
    theme_minimal()
   # theme(axis.text.x = element_text(angle=45)) +
   # scale_y_continuous(labels = scales::label_comma() ) +
    #scale_x_continuous(breaks = scales::pretty_breaks(n = 15))

ggplotly(p) %>% layout(showlegend = FALSE)
```



#### 3- Positional Base Content

Number of bases of each specific nucleotide at given locations in the read. Locations are given first and can be either specific positions or ranges. The nucleotide is listed second and can be A, C, G, T, N.


Per-Position Sequence Content heatmap and Per-Position N Content

```{r, echo =FALSE, message=FALSE, results='hide'}
position_base_content <- All_files %>% filter(V1 == "POSITIONAL BASE CONTENT")
head(position_base_content)
position_base_content$V3 <- position_base_content$V3 %>% str_remove("ReadPos ") %>% 
                                                         str_remove(" Bases")
position_base_content <- position_base_content %>% separate(V3, c("ReadPos", "Bases"))
position_base_content$ReadPos <- as.numeric(position_base_content$ReadPos)
head(position_base_content)
```

 

```{r, echo =FALSE, message=FALSE, results='hide'}

#Now calculate % bases


position_base_content <-position_base_content %>% group_by(Sample, ReadPos) %>% 
                                                  mutate(Total = sum(V4)) 


position_base_content_w <- position_base_content  %>% pivot_wider(names_from = Bases,
                                       values_from = c(V4)) %>% 
                                       mutate(Total = A+C+G+T+N)
position_base_content_w <- position_base_content_w %>% 
                                        mutate(pcT = T*100/Total) %>% 
                                        mutate(pcA = A*100/Total) %>% 
                                        mutate(pcC = C*100/Total) %>% 
                                        mutate(pcG = G*100/Total) %>% 
                                        mutate(pcN = N*100/Total) %>% 
                                        mutate(sumPC = pcT+pcA+pcC+pcG+pcN)

```




```{r, echo =FALSE, message=FALSE}
#heatmap
p <- ggplot(position_base_content_w, aes(ReadPos, Sample, fill= pcT)) + 
  geom_tile() +
  scale_fill_gradient(low="white", high="red4")+ 
  labs(title ="Dragen-QC: Per-Base position sequence Content; %T")+
  theme(axis.text.y = element_blank()) +
  theme(panel.background = element_rect(fill = "white"),
        panel.grid.major = element_line(colour = "grey90"))

  

ggplotly(p)

```

```{r, echo =FALSE, message=FALSE}
#heatmap
p <- ggplot(position_base_content_w, aes(ReadPos, Sample, fill= pcA)) + 
  geom_tile() +
  scale_fill_gradient(low="white", high="yellow4")+ 
  labs(title ="Dragen-QC: Per-Base position sequence Content; %A")+
  theme(axis.text.y = element_blank()) +
  theme(panel.background = element_rect(fill = "white"),
        panel.grid.major = element_line(colour = "grey90"))

ggplotly(p)

```

```{r, echo =FALSE, message=FALSE}
#heatmap
p <- ggplot(position_base_content_w, aes(ReadPos, Sample, fill= pcC)) + 
  geom_tile() +
  scale_fill_gradient(low="white", high="green4")+ 
  labs(title ="Dragen-QC: Per-Base position sequence Content; %C")+
  theme(axis.text.y = element_blank()) +
  theme(panel.background = element_rect(fill = "white"),
        panel.grid.major = element_line(colour = "grey90"))

ggplotly(p)

```

```{r, echo =FALSE, message=FALSE}
#heatmap
p <- ggplot(position_base_content_w, aes(ReadPos, Sample, fill= pcG)) + 
  geom_tile() +
  scale_fill_gradient(low="white", high="blue4")+ 
  labs(title ="Dragen-QC: Per-Base position sequence Content; %G")+
  theme(axis.text.y = element_blank()) +
  theme(panel.background = element_rect(fill = "white"),
        panel.grid.major = element_line(colour = "grey90"))

ggplotly(p)

```

```{r, echo =FALSE, message=FALSE}
#heatmap
p <- ggplot(position_base_content_w, aes(ReadPos, Sample, fill= pcN)) + 
  geom_tile() +
  scale_fill_gradient(low="white", high="black")+ 
  labs(title ="Dragen-QC: Per-Base position sequence Content; %N")+
  theme(axis.text.y = element_blank()) +
  theme(panel.background = element_rect(fill = "white"),
       panel.grid.major = element_line(colour = "grey90"))

ggplotly(p)

```

#### 4- Read length

Total number of reads with each observed length. 

```{r, echo =FALSE, message=FALSE, results='hide'}
read_lengths <- All_files %>% filter(V1 == "READ LENGTHS")
head(read_lengths)
read_lengths$V3 <- read_lengths$V3 %>% str_remove("bp Length Reads")

read_lengths$V3 <- as.numeric(read_lengths$V3)
names(read_lengths)[names(read_lengths) == 'V3'] <- 'Length'
names(read_lengths)[names(read_lengths) == 'V4'] <- 'ReadCount'
head(read_lengths)
```

```{r, echo =FALSE, message=FALSE}
p <-ggplot(data =read_lengths,  aes(x= Length, y=ReadCount, color = Sample )) +
    labs(title ="Dragen-QC: Sequence Length Distribution", y= "Read Count", x = "Sequence Length (bp)") +
    geom_line() +
    theme(legend.position = "none")  +
    #theme(axis.text.x = element_text(angle=45)) +
    scale_y_continuous(labels = scales::label_comma() ) +
    scale_x_continuous(breaks = scales::pretty_breaks(n = 15)) +
    theme_minimal()

ggplotly(p) %>% layout(showlegend = FALSE)
```





#### 5- Read GC Content; Per-Sequence GC Content

Total number of reads with each GC content percentile between 0% and 100%.


```{r, echo =FALSE, message=FALSE, results='hide'}
read_gc_content <- All_files %>% filter(V1 == "READ GC CONTENT")
head(read_gc_content, n=4)

read_gc_content$V3 <- read_gc_content$V3 %>% str_remove("% GC Reads") %>% 
                                             as.numeric()
head(read_gc_content, n=4)

read_gc_content <- read_gc_content %>% 
                   group_by(Sample) %>% 
                   mutate(Total_read = sum(V4)) 

read_gc_content <- read_gc_content %>% 
                   group_by(Sample) %>% 
                   mutate(PercentRead = (V4*100)/Total_read)  %>% 
                   mutate(tt = sum(PercentRead))

names(read_gc_content)[names(read_gc_content) == 'V3'] <- 'PercentGC'
names(read_gc_content)[names(read_gc_content) == 'V4'] <- 'ReadCount'
head(read_gc_content)
```

```{r,echo =FALSE, message=FALSE}
p <-ggplot(data =read_gc_content,  aes(x= PercentGC, y=ReadCount, color = Sample )) +
    labs(title ="Dragen-QC: Per-Sequence GC Content", y= "Count", x = "% GC") +
    geom_line() +
    theme(legend.position = "none")  +
    #theme(axis.text.x = element_text(angle=45)) +
    scale_y_continuous(labels = scales::label_comma() ) +
    scale_x_continuous(breaks = scales::pretty_breaks(n = 15)) +
    theme_minimal()

ggplotly(p) %>% layout(showlegend = FALSE)
```

```{r, echo =FALSE, message=FALSE}
p <-ggplot(data =read_gc_content,  aes(x= PercentGC, y=PercentRead, color = Sample )) +
    labs(title ="Dragen-QC: Per-Sequence GC Content", y= "% Reads", x = "% GC") +
    geom_line() +
    theme(legend.position = "none")  +
    #theme(axis.text.x = element_text(angle=45)) +
    #scale_y_continuous(labels = scales::label_percent(scale = 100) ) +
    scale_x_continuous(breaks = scales::pretty_breaks(n = 15)) +   
    theme_minimal()

ggplotly(p) %>% layout(showlegend = FALSE)

```



#### 6- Read GC Content Quality; Average mean quality for reads by GC%

Average Phred-scale read mean quality for reads with each GC content percentile between 0% and 100%.

```{r, echo =FALSE, message=FALSE, results='hide'}
read_gc_content_quality <- All_files %>% filter(V1 == "READ GC CONTENT QUALITY")

read_gc_content_quality$V3 <- read_gc_content_quality$V3 %>% str_remove("% GC Reads Average Quality") %>% 
                                                            as.numeric()

names(read_gc_content_quality)[names(read_gc_content_quality) == 'V3'] <- 'PercentGC'
names(read_gc_content_quality)[names(read_gc_content_quality) == 'V4'] <- 'PhredScore'

head(read_gc_content_quality)

```

```{r, echo =FALSE, message=FALSE}

p <- ggplot(data =read_gc_content_quality,  aes(x= PercentGC, y=PhredScore, color = Sample )) +
    labs(title ="Dragen-QC: Average mean quality for reads vs GC% ", y= "Phred Quality Score", x = "% GC content") +
    geom_line() +
    theme(legend.position = "none")  +
    scale_y_continuous(breaks = scales::pretty_breaks(n = 20)) +
    theme_minimal()

ggplotly(p) %>% layout(showlegend = FALSE)

```



#### 6- Sequence Positions; Cumulative Adapter Content

Number of times an adapter or other kmer sequence is found, starting at a given position in the input reads. 


```{r, echo =FALSE, message=FALSE, results='hide'}
sequence_positions <- All_files %>% filter(V1 == "SEQUENCE POSITIONS")

sequence_positions_total <- sequence_positions %>% filter(V3 == "'AGATCGGAAGAG' Total Sequence Starts")  %>% 
                                             select("Sample", "V4")
head(sequence_positions)
```

```{r, echo =FALSE, message=FALSE, results='hide'}
colnames(sequence_positions_total)[names(sequence_positions_total) == "V4"] <- "Total"
sequence_positions <- sequence_positions %>%  filter(V4 != "'AGATCGGAAGAG' Total Sequence Starts")
  
sequence_positions <- sequence_positions %>% left_join(sequence_positions_total)
```


```{r, echo =FALSE, message=FALSE, results='hide', warning = FALSE}
sequence_positions$V3 <- sequence_positions$V3 %>% str_remove("'AGATCGGAAGAG' ") %>% 
                                                   str_remove("bp Starts") %>% 
                                                   as.numeric()
sequence_positions <- sequence_positions %>% group_by(Sample) %>%  
                                             mutate(csum = cumsum(V4)) %>% 
                                             mutate(Total_read = sum(V4)) %>% 
                                             mutate(perct = csum*100/Total_read)
names(sequence_positions)[names(sequence_positions) == 'V3'] <- 'SequencePosition'
head(sequence_positions) 
```




```{r, echo =FALSE, message=FALSE}

p <- ggplot(data =sequence_positions,  aes(x= SequencePosition, y=perct, color = Sample )) +
    labs(title ="Dragen-QC: Cumulative Adapter Content", y= "% of sequences", x = "Sequence Position (bp)") +
    geom_line() +
    theme(legend.position = "none") + 
    theme_minimal()

ggplotly(p) %>% layout(showlegend = FALSE)

```




#### 7- Positional Quality

Phred-scale quality value for bases at a given location and a given quantile of the distribution. Locations are listed first and can be either specific positions or ranges. Quantiles are listed second and can be any whole integer 0‚Äì100.  
  
This plot represent the same type of plot as the Box and Whisker plot generated by [fastQC](https://www.bioinformatics.babraham.ac.uk/projects/fastqc). The major difference is that here I plot all values from fastqc output and not just min, max and the interquartile range.
For samples with low phred score, the plot will become darker. The brighter the plot, the better the overall score.   

```{r, echo =FALSE, message=FALSE, results='hide'}
position_qual <- All_files %>% filter(V1 == "POSITIONAL QUALITY")
head(position_qual, n= 20)
```


```{r, echo =FALSE, message=FALSE, results='hide'}
position_qual$V3 <- position_qual$V3 %>% str_remove("% Quantile QV")

position_qual <- position_qual %>% separate(V3, c("Nm", "ReadPos", "PctQuantile"))
names(position_qual)[names(position_qual) == 'V4'] <- 'PhredScore'
head(position_qual, n= 20)
position_qual$ReadPos <- as.numeric(position_qual$ReadPos)
position_qual$PctQuantile <- factor(position_qual$PctQuantile, levels = rev(c("99", "98", "95", "90", "75", "50",  "25", "10", "5", "2",  "1")))
position_qual$PctQuantile <- factor(position_qual$PctQuantile, levels=rev(levels(position_qual$PctQuantile)))
head(position_qual, n= 20)
levels(position_qual$PctQuantile)

```


```{r, echo =FALSE, message=FALSE}
# Single plot as example, loop plot for all samples below
colors <- rev(c("#FFF5EB", "#FEE9D3", "#FDD8B3", "#FDC28B", "#FDA761", "#FD8D3C",
            "#F3701B", "#E25508", "#C44001", "#9E3203", "#7F2704"))

p <- ggplot(position_qual, aes(x=ReadPos, y=PhredScore, fill=PctQuantile)) + 
    geom_area(position = "identity")+
    scale_fill_manual(values=colors)+
    scale_x_continuous(breaks = scales::pretty_breaks(n = 20)) +
    scale_y_continuous(breaks=seq(0,37,1)) +
    theme(panel.background = element_rect(fill = "white"),
    panel.grid.major = element_line(colour = "grey90"))


ggplotly(p)
```








